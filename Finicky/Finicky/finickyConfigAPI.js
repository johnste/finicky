var finickyConfigApi = (function (exports) {
    'use strict';

    
    /*
        Finicky Config API 1.0.0
        This file is automatically generated. Please refer to the `config-api` folder to build a new one.
    */

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function isDefined(value) {
        return typeof value !== "undefined";
    }
    function formatValue(value) {
        if (value instanceof RegExp) {
            return value.toString();
        }
        else if (Array.isArray(value)) {
            return "[Array]";
        }
        else if (typeof value === "function") {
            return "[Function" + (value.name ? " " + value.name : "") + "]";
        }
        else if (value instanceof Date) {
            return "[Date]";
        }
        else if (value === null) {
            return "[null]";
        }
        else if (value === undefined) {
            return "[undefined]";
        }
        return "[" + JSON.stringify(value, null, 2) + "]";
    }
    function getKeys(object) {
        return Object.keys(object).filter(function (key) { return Object.prototype.hasOwnProperty.call(object, key); });
    }
    function enumerate(names, mode) {
        if (mode === void 0) { mode = "or"; }
        if (names.length === 0) {
            return "";
        }
        if (names.length == 1) {
            return names[0];
        }
        var _a = names.reverse(), tail = _a[0], body = _a.slice(1);
        return body.join(", ") + " " + mode + " " + tail;
    }

    function getTypeName(typeName) {
        if (typeof typeName === "string") {
            return typeName;
        }
        return JSON.stringify(typeName, null, 2);
    }
    function createValidator(typeName, typeCallback) {
        function isOptional(value, key) {
            if (!isDefined(value)) {
                return undefined;
            }
            var result = typeCallback(value, key);
            if (typeof result === "boolean" && !result) {
                return "Value at " + key + ": " + formatValue(value) + " is not " + getTypeName(typeName);
            }
            else if (Array.isArray(result) && result.length > 0) {
                return result.join("\n");
            }
        }
        function isRequired(value, key) {
            if (!isDefined(value)) {
                return "Expected \"" + key + "\" to be " + getTypeName(typeName);
            }
            return isOptional(value, key);
        }
        isRequired.typeName = typeName;
        function checkType(value, key) {
            return isOptional(value, key);
        }
        checkType.isRequired = isRequired;
        // Save typeName for nice error messages
        checkType.typeName = typeName;
        return checkType;
    }

    function getErrors(object, schema, prefix) {
        if (prefix === void 0) { prefix = "root."; }
        // If schema is a function we're testing a single validator
        if (typeof schema === "function") {
            var result = schema(object, prefix + "value");
            return result ? [result] : [];
        }
        else if (typeof schema !== "object") {
            return [
                "Expected an schema that was an object or a function, but received " + typeof object + " (path: " + prefix + ")"
            ];
        }
        var schemaKeys = getKeys(schema);
        var errors = [];
        if (typeof object !== "object" || object === null) {
            errors.push("Expected an object to validate, but received " + typeof object + " (path: " + prefix + ")");
        }
        else {
            // Validate each property in schema
            schemaKeys.forEach(function (key) {
                var propChecker = schema[key];
                var result;
                if (typeof propChecker === "function") {
                    result = propChecker(object[key], prefix + key);
                }
                else if (["string", "number"].includes(typeof propChecker)) {
                    result = validate.value(propChecker)(object[key], prefix + key);
                }
                else {
                    result = "Expected a validator at path " + (prefix + key);
                }
                if (typeof result === "string") {
                    errors.push(result);
                }
            });
            // Check for extraneous properties in object
            getKeys(object).forEach(function (key) {
                if (!schemaKeys.includes(key)) {
                    errors.push("unknown key " + key + " at " + (prefix + key));
                }
            });
        }
        return errors;
    }
    var validate = {
        boolean: createValidator("boolean", function (value) { return typeof value === "boolean"; }),
        string: createValidator("string", function (value) { return typeof value === "string"; }),
        number: createValidator("number", function (value) { return typeof value === "number" && !Number.isNaN(value); }),
        function: function (argNames) {
            if (!Array.isArray(argNames)) {
                if (argNames) {
                    argNames = [argNames];
                }
                else {
                    argNames = [];
                }
            }
            var name = "function(" + argNames.join(", ") + ")";
            return createValidator(name, function (value) { return typeof value === "function"; });
        },
        regex: createValidator("regex", function (value) { return value instanceof RegExp; }),
        value: function (expectedValue) {
            return createValidator(expectedValue, function (value) {
                return value === expectedValue;
            });
        },
        shape: function (schema) {
            var names = getNameType(schema);
            return createValidator(names, function (value, key) {
                if (typeof value !== "object" || value === null) {
                    return false;
                }
                return getErrors(value, schema, key + ".");
            });
        },
        arrayOf: function (validator) {
            return createValidator("array", function (value, key) {
                if (!Array.isArray(value)) {
                    return false;
                }
                return value.reduce(function (errors, item, index) {
                    var result = validator(item, key + "[" + index + "]");
                    if (typeof result === "string") {
                        return errors.concat([result]);
                    }
                    return errors;
                }, []);
            });
        },
        oneOf: function (OneOfs) {
            var typeCheckers = OneOfs.map(function (v) {
                if (["string", "number"].includes(typeof v)) {
                    return validate.value(v);
                }
                return v;
            });
            var description = enumerate(typeCheckers.map(function (oneOf) { return getTypeName(oneOf.typeName); }));
            return createValidator("" + description, function (value, key) {
                var errors = typeCheckers.every(function (oneOfValidator) { return typeof oneOfValidator(value, key) === "string"; });
                return errors ? [key + ": Value not one of " + description] : true;
            });
        }
    };
    function getNameType(schema) {
        var names = {};
        var schemaKeys = getKeys(schema);
        schemaKeys.forEach(function (key) {
            var property = schema[key];
            if (typeof property === "number" || typeof property === "string") {
                names[key] = typeof property;
            }
            else {
                names[key] = property.typeName;
            }
        });
        return names;
    }

    var urlSchema = {
        url: validate.oneOf([
            validate.string,
            validate.shape({
                protocol: validate.oneOf(["http", "https"]).isRequired,
                username: validate.string,
                password: validate.string,
                host: validate.string.isRequired,
                port: validate.oneOf([validate.number, validate.value(null)]),
                pathname: validate.string,
                search: validate.string,
                hash: validate.string
            })
        ]).isRequired
    };
    var browserSchema = validate.oneOf([
        validate.string,
        validate.shape({
            name: validate.string.isRequired,
            appType: validate.oneOf(["appName", "bundleId"]),
            openInBackground: validate.boolean
        }),
        validate.function("options"),
        validate.value(null)
    ]);
    var multipleBrowsersSchema = validate.oneOf([
        browserSchema,
        validate.arrayOf(browserSchema.isRequired)
    ]);
    var matchSchema = validate.oneOf([
        validate.string,
        validate.function("options"),
        validate.regex,
        validate.arrayOf(validate.oneOf([
            validate.string,
            validate.function("options"),
            validate.regex
        ]))
    ]);
    var finickyConfigSchema = {
        defaultBrowser: multipleBrowsersSchema.isRequired,
        options: validate.shape({
            hideIcon: validate.boolean,
            urlShorteners: validate.arrayOf(validate.string)
        }),
        rewrite: validate.arrayOf(validate.shape({
            match: matchSchema.isRequired,
            url: validate.oneOf([validate.string, validate.function("options")])
                .isRequired
        }).isRequired),
        handlers: validate.arrayOf(validate.shape({
            match: matchSchema.isRequired,
            browser: multipleBrowsersSchema.isRequired
        }))
    };

    var appDescriptorSchema = {
        name: validate.string,
        appType: validate.oneOf([
            validate.value("bundleId"),
            validate.value("appName"),
            validate.value("none")
        ]).isRequired,
        openInBackground: validate.boolean
    };
    function processUrl(config, url, processOptions) {
        if (!processOptions) {
            processOptions = {
                keys: {
                    capsLock: false,
                    command: false,
                    shift: false,
                    option: false,
                    control: false,
                    function: false
                }
            };
        }
        var options = __assign({ urlString: url, url: finicky.getUrlParts(url) }, processOptions);
        if (!config) {
            return processBrowserResult("Safari", options);
        }
        options = rewriteUrl(config, options);
        if (Array.isArray(config.handlers)) {
            for (var _i = 0, _a = config.handlers; _i < _a.length; _i++) {
                var handler = _a[_i];
                if (isMatch(handler.match, options)) {
                    return processBrowserResult(handler.browser, options);
                }
            }
        }
        return processBrowserResult(config.defaultBrowser, options);
    }
    function validateSchema(value, schema, path) {
        if (path === void 0) { path = ""; }
        var errors = getErrors(value, schema, path);
        if (errors.length > 0) {
            throw new Error(errors.join("\n") + "\nReceived value: " + JSON.stringify(value, null, 2));
        }
    }
    function createUrl(url) {
        var protocol = url.protocol, host = url.host, _a = url.pathname, pathname = _a === void 0 ? "" : _a;
        var port = url.port ? ":" + url.port : "";
        var search = url.search ? "?" + url.search : "";
        var hash = url.hash ? "#" + url.hash : "";
        var auth = url.username ? "" + url.username : "";
        auth += url.password ? ":" + url.password : "";
        return protocol + "://" + auth + host + port + pathname + search + hash;
    }
    function rewriteUrl(config, options) {
        if (Array.isArray(config.rewrite)) {
            for (var _i = 0, _a = config.rewrite; _i < _a.length; _i++) {
                var rewrite = _a[_i];
                if (isMatch(rewrite.match, options)) {
                    var urlResult = resolveFn(rewrite.url, options);
                    validateSchema({ url: urlResult }, urlSchema);
                    if (typeof urlResult === "string") {
                        options = __assign({}, options, { url: finicky.getUrlParts(urlResult), urlString: urlResult });
                    }
                    else {
                        options = __assign({}, options, { url: urlResult, urlString: createUrl(urlResult) });
                    }
                }
            }
        }
        return options;
    }
    function isMatch(matcher, options) {
        if (!matcher) {
            return false;
        }
        var matchers = Array.isArray(matcher) ? matcher : [matcher];
        return matchers.some(function (matcher) {
            if (matcher instanceof RegExp) {
                return matcher.test(options.urlString);
            }
            else if (typeof matcher === "string") {
                return matcher === options.urlString;
            }
            else if (typeof matcher === "function") {
                return !!matcher(options);
            }
            return false;
        });
    }
    // Recursively resolve handler to value
    function resolveFn(result, options) {
        if (typeof result === "function") {
            return result(options);
        }
        return result;
    }
    function getAppType(value) {
        if (value === null) {
            return "none";
        }
        return looksLikeBundleIdentifier(value) ? "bundleId" : "appName";
    }
    function processBrowserResult(result, options) {
        var browser = resolveFn(result, options);
        if (!Array.isArray(browser)) {
            browser = [browser];
        }
        var browsers = browser.map(createBrowser);
        return { browsers: browsers, url: options.urlString };
    }
    function createBrowser(browser) {
        // If all we got was a string, try to figure out if it's a bundle identifier or an application name
        if (typeof browser === "string" || browser === null) {
            browser = {
                name: browser
            };
        }
        if (typeof browser === "object" && !browser.appType) {
            var name_1 = browser.name === null ? "" : browser.name;
            browser = __assign({}, browser, { name: name_1, appType: getAppType(browser.name) });
        }
        validateSchema(browser, appDescriptorSchema);
        return browser;
    }
    function looksLikeBundleIdentifier(value) {
        // Regular expression to match Uniform Type Identifiers
        // Adapted from https://stackoverflow.com/a/34241710/1698327
        var bundleIdRegex = /^[A-Za-z]{2,6}((?!-)\.[A-Za-z0-9-]{1,63})+$/;
        if (bundleIdRegex.test(value)) {
            return true;
        }
        return false;
    }

    function validateConfig(config) {
        var invalid = getErrors(config, finickyConfigSchema, "module.exports.");
        if (invalid.length === 0) {
            return true;
        }
        throw new Error(invalid.join("\n"));
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    /**
     * Check if we're required to add a port number.
     *
     * @see https://url.spec.whatwg.org/#default-port
     * @param {Number|String} port Port number we need to check
     * @param {String} protocol Protocol we need to check against.
     * @returns {Boolean} Is it a default port for the given protocol
     * @api private
     */
    var requiresPort = function required(port, protocol) {
      protocol = protocol.split(':')[0];
      port = +port;

      if (!port) return false;

      switch (protocol) {
        case 'http':
        case 'ws':
        return port !== 80;

        case 'https':
        case 'wss':
        return port !== 443;

        case 'ftp':
        return port !== 21;

        case 'gopher':
        return port !== 70;

        case 'file':
        return false;
      }

      return port !== 0;
    };

    var has = Object.prototype.hasOwnProperty
      , undef;

    /**
     * Decode a URI encoded string.
     *
     * @param {String} input The URI encoded string.
     * @returns {String|Null} The decoded string.
     * @api private
     */
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, ' '));
      } catch (e) {
        return null;
      }
    }

    /**
     * Simple query string parser.
     *
     * @param {String} query The query string that needs to be parsed.
     * @returns {Object}
     * @api public
     */
    function querystring(query) {
      var parser = /([^=?&]+)=?([^&]*)/g
        , result = {}
        , part;

      while (part = parser.exec(query)) {
        var key = decode(part[1])
          , value = decode(part[2]);

        //
        // Prevent overriding of existing properties. This ensures that build-in
        // methods like `toString` or __proto__ are not overriden by malicious
        // querystrings.
        //
        // In the case if failed decoding, we want to omit the key/value pairs
        // from the result.
        //
        if (key === null || value === null || key in result) continue;
        result[key] = value;
      }

      return result;
    }

    /**
     * Transform a query string to an object.
     *
     * @param {Object} obj Object that should be transformed.
     * @param {String} prefix Optional prefix.
     * @returns {String}
     * @api public
     */
    function querystringify(obj, prefix) {
      prefix = prefix || '';

      var pairs = []
        , value
        , key;

      //
      // Optionally prefix with a '?' if needed
      //
      if ('string' !== typeof prefix) prefix = '?';

      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];

          //
          // Edge cases where we actually want to encode the value to an empty
          // string instead of the stringified value.
          //
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = '';
          }

          key = encodeURIComponent(key);
          value = encodeURIComponent(value);

          //
          // If we failed to encode the strings, we should bail out as we don't
          // want to add invalid strings to the query.
          //
          if (key === null || value === null) continue;
          pairs.push(key +'='+ value);
        }
      }

      return pairs.length ? prefix + pairs.join('&') : '';
    }

    //
    // Expose the module.
    //
    var stringify = querystringify;
    var parse = querystring;

    var querystringify_1 = {
    	stringify: stringify,
    	parse: parse
    };

    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
      , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
      , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
      , left = new RegExp('^'+ whitespace +'+');

    /**
     * Trim a given string.
     *
     * @param {String} str String to trim.
     * @public
     */
    function trimLeft(str) {
      return (str ? str : '').toString().replace(left, '');
    }

    /**
     * These are the parse rules for the URL parser, it informs the parser
     * about:
     *
     * 0. The char it Needs to parse, if it's a string it should be done using
     *    indexOf, RegExp using exec and NaN means set as current value.
     * 1. The property we should set when parsing this value.
     * 2. Indication if it's backwards or forward parsing, when set as number it's
     *    the value of extra chars that should be split off.
     * 3. Inherit from location if non existing in the parser.
     * 4. `toLowerCase` the resulting value.
     */
    var rules = [
      ['#', 'hash'],                        // Extract from the back.
      ['?', 'query'],                       // Extract from the back.
      function sanitize(address) {          // Sanitize what is left of the address
        return address.replace('\\', '/');
      },
      ['/', 'pathname'],                    // Extract from the back.
      ['@', 'auth', 1],                     // Extract from the front.
      [NaN, 'host', undefined, 1, 1],       // Set left over value.
      [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
      [NaN, 'hostname', undefined, 1, 1]    // Set left over.
    ];

    /**
     * These properties should not be copied or inherited from. This is only needed
     * for all non blob URL's as a blob URL does not include a hash, only the
     * origin.
     *
     * @type {Object}
     * @private
     */
    var ignore = { hash: 1, query: 1 };

    /**
     * The location object differs when your code is loaded through a normal page,
     * Worker or through a worker using a blob. And with the blobble begins the
     * trouble as the location object will contain the URL of the blob, not the
     * location of the page where our code is loaded in. The actual origin is
     * encoded in the `pathname` so we can thankfully generate a good "default"
     * location from it so we can generate proper relative URL's again.
     *
     * @param {Object|String} loc Optional default location object.
     * @returns {Object} lolcation object.
     * @public
     */
    function lolcation(loc) {
      var globalVar;

      if (typeof window !== 'undefined') globalVar = window;
      else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;
      else if (typeof self !== 'undefined') globalVar = self;
      else globalVar = {};

      var location = globalVar.location || {};
      loc = loc || location;

      var finaldestination = {}
        , type = typeof loc
        , key;

      if ('blob:' === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ('string' === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ('object' === type) {
        for (key in loc) {
          if (key in ignore) continue;
          finaldestination[key] = loc[key];
        }

        if (finaldestination.slashes === undefined) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }

      return finaldestination;
    }

    /**
     * @typedef ProtocolExtract
     * @type Object
     * @property {String} protocol Protocol matched in the URL, in lowercase.
     * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
     * @property {String} rest Rest of the URL that is not part of the protocol.
     */

    /**
     * Extract protocol information from a URL with/without double slash ("//").
     *
     * @param {String} address URL we want to extract from.
     * @return {ProtocolExtract} Extracted information.
     * @private
     */
    function extractProtocol(address) {
      address = trimLeft(address);
      var match = protocolre.exec(address);

      return {
        protocol: match[1] ? match[1].toLowerCase() : '',
        slashes: !!match[2],
        rest: match[3]
      };
    }

    /**
     * Resolve a relative URL pathname against a base URL pathname.
     *
     * @param {String} relative Pathname of the relative URL.
     * @param {String} base Pathname of the base URL.
     * @return {String} Resolved pathname.
     * @private
     */
    function resolve(relative, base) {
      if (relative === '') return base;

      var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
        , i = path.length
        , last = path[i - 1]
        , unshift = false
        , up = 0;

      while (i--) {
        if (path[i] === '.') {
          path.splice(i, 1);
        } else if (path[i] === '..') {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0) unshift = true;
          path.splice(i, 1);
          up--;
        }
      }

      if (unshift) path.unshift('');
      if (last === '.' || last === '..') path.push('');

      return path.join('/');
    }

    /**
     * The actual URL instance. Instead of returning an object we've opted-in to
     * create an actual constructor as it's much more memory efficient and
     * faster and it pleases my OCD.
     *
     * It is worth noting that we should not use `URL` as class name to prevent
     * clashes with the global URL instance that got introduced in browsers.
     *
     * @constructor
     * @param {String} address URL we want to parse.
     * @param {Object|String} [location] Location defaults for relative paths.
     * @param {Boolean|Function} [parser] Parser for the query string.
     * @private
     */
    function Url(address, location, parser) {
      address = trimLeft(address);

      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }

      var relative, extracted, parse, instruction, index, key
        , instructions = rules.slice()
        , type = typeof location
        , url = this
        , i = 0;

      //
      // The following if statements allows this module two have compatibility with
      // 2 different API:
      //
      // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
      //    where the boolean indicates that the query string should also be parsed.
      //
      // 2. The `URL` interface of the browser which accepts a URL, object as
      //    arguments. The supplied object will be used as default values / fall-back
      //    for relative paths.
      //
      if ('object' !== type && 'string' !== type) {
        parser = location;
        location = null;
      }

      if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;

      location = lolcation(location);

      //
      // Extract protocol information before running the instructions.
      //
      extracted = extractProtocol(address || '');
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || '';
      address = extracted.rest;

      //
      // When the authority component is absent the URL starts with a path
      // component.
      //
      if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

      for (; i < instructions.length; i++) {
        instruction = instructions[i];

        if (typeof instruction === 'function') {
          address = instruction(address);
          continue;
        }

        parse = instruction[0];
        key = instruction[1];

        if (parse !== parse) {
          url[key] = address;
        } else if ('string' === typeof parse) {
          if (~(index = address.indexOf(parse))) {
            if ('number' === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if ((index = parse.exec(address))) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }

        url[key] = url[key] || (
          relative && instruction[3] ? location[key] || '' : ''
        );

        //
        // Hostname, host and protocol should be lowercased so they can be used to
        // create a proper `origin`.
        //
        if (instruction[4]) url[key] = url[key].toLowerCase();
      }

      //
      // Also parse the supplied query string in to an object. If we're supplied
      // with a custom parser as function use that instead of the default build-in
      // parser.
      //
      if (parser) url.query = parser(url.query);

      //
      // If the URL is relative, resolve the pathname against the base URL.
      //
      if (
          relative
        && location.slashes
        && url.pathname.charAt(0) !== '/'
        && (url.pathname !== '' || location.pathname !== '')
      ) {
        url.pathname = resolve(url.pathname, location.pathname);
      }

      //
      // We should not add port numbers if they are already the default port number
      // for a given protocol. As the host also contains the port number we're going
      // override it with the hostname which contains no port number.
      //
      if (!requiresPort(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = '';
      }

      //
      // Parse down the `auth` for the username and password.
      //
      url.username = url.password = '';
      if (url.auth) {
        instruction = url.auth.split(':');
        url.username = instruction[0] || '';
        url.password = instruction[1] || '';
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      //
      // The href is just the compiled result.
      //
      url.href = url.toString();
    }

    /**
     * This is convenience method for changing properties in the URL instance to
     * insure that they all propagate correctly.
     *
     * @param {String} part          Property we need to adjust.
     * @param {Mixed} value          The newly assigned value.
     * @param {Boolean|Function} fn  When setting the query, it will be the function
     *                               used to parse the query.
     *                               When setting the protocol, double slash will be
     *                               removed from the final url if it is true.
     * @returns {URL} URL instance for chaining.
     * @public
     */
    function set(part, value, fn) {
      var url = this;

      switch (part) {
        case 'query':
          if ('string' === typeof value && value.length) {
            value = (fn || querystringify_1.parse)(value);
          }

          url[part] = value;
          break;

        case 'port':
          url[part] = value;

          if (!requiresPort(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = '';
          } else if (value) {
            url.host = url.hostname +':'+ value;
          }

          break;

        case 'hostname':
          url[part] = value;

          if (url.port) value += ':'+ url.port;
          url.host = value;
          break;

        case 'host':
          url[part] = value;

          if (/:\d+$/.test(value)) {
            value = value.split(':');
            url.port = value.pop();
            url.hostname = value.join(':');
          } else {
            url.hostname = value;
            url.port = '';
          }

          break;

        case 'protocol':
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;

        case 'pathname':
        case 'hash':
          if (value) {
            var char = part === 'pathname' ? '/' : '#';
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;

        default:
          url[part] = value;
      }

      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];

        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      url.href = url.toString();

      return url;
    }

    /**
     * Transform the properties back in to a valid and full URL string.
     *
     * @param {Function} stringify Optional query stringify function.
     * @returns {String} Compiled version of the URL.
     * @public
     */
    function toString(stringify) {
      if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;

      var query
        , url = this
        , protocol = url.protocol;

      if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

      var result = protocol + (url.slashes ? '//' : '');

      if (url.username) {
        result += url.username;
        if (url.password) result += ':'+ url.password;
        result += '@';
      }

      result += url.host + url.pathname;

      query = 'object' === typeof url.query ? stringify(url.query) : url.query;
      if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

      if (url.hash) result += url.hash;

      return result;
    }

    Url.prototype = { set: set, toString: toString };

    //
    // Expose the URL parser and some additional properties that might be useful for
    // others or testing.
    //
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = querystringify_1;

    var urlParse = Url;

    /**
     * Extends finicky js api with some utility functions.
     */
    function createAPI(options) {
        if (options === void 0) { options = {}; }
        var log = options.log ||
            (function (message) {
                // @ts-ignore
                if (typeof finickyInternalAPI !== "undefined") {
                    // @ts-ignore
                    finickyInternalAPI.log(message);
                }
                else {
                    console.log("[finicky log] " + message);
                }
            });
        var notify = options.notify ||
            (function (title, subtitle) {
                // @ts-ignore
                if (typeof finickyInternalAPI !== "undefined") {
                    // @ts-ignore
                    finickyInternalAPI.notify(title, subtitle);
                }
                else {
                    console.log("[finicky notify] " + title + " " + subtitle);
                }
            });
        var getUrlParts = function (urlString) {
            var url = urlParse(urlString);
            // Mistake in the urlParse typings. query should be a string unless parsing of query is enabled
            var search = url.query;
            return {
                username: url.username,
                host: url.hostname,
                protocol: url.protocol.replace(":", ""),
                pathname: url.pathname,
                search: search.replace("?", ""),
                password: url.password,
                port: url.port ? +url.port : undefined,
                hash: url.hash.replace("#", "")
            };
        };
        var matchDomains = function (matchers) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (args.length > 0) {
                throw new Error("finicky.matchDomains(domains) only accepts one argument. See https://johnste.github.io/finicky-docs/interfaces/_finickyapi_.finicky.html#matchdomains for more information");
            }
            if (!Array.isArray(matchers)) {
                matchers = [matchers];
            }
            matchers.forEach(function (matcher) {
                if (matcher instanceof RegExp || typeof matcher === "string") {
                    return;
                }
                throw new Error("finicky.matchDomains(domains): Unrecognized domain \"" + matcher + "\"");
            });
            return function (_a) {
                var url = _a.url;
                var domain = url.host;
                return matchers.some(function (matcher) {
                    if (matcher instanceof RegExp) {
                        return matcher.test(domain);
                    }
                    else if (typeof matcher === "string") {
                        return matcher === domain;
                    }
                    return false;
                });
            };
        };
        // Warn when using deprecated API methods
        var onUrl = function () {
            log("finicky.onUrl is no longer supported in this version of Finicky, please go to https://github.com/johnste/finicky for updated documentation");
            notify("finicky.onUrl is no longer supported", "Check the Finicky website for updated documentation");
        };
        var setDefaultBrowser = function () {
            log("finicky.setDefaultBrowser is no longer supported in this version of Finicky, please go to https://github.com/johnste/finicky for updated documentation");
            notify("finicky.setDefaultBrowser is no longer supported", "Check the Finicky website for updated documentation");
        };
        return {
            log: log,
            notify: notify,
            matchDomains: matchDomains,
            getUrlParts: getUrlParts,
            onUrl: onUrl,
            setDefaultBrowser: setDefaultBrowser
        };
    }

    exports.createAPI = createAPI;
    exports.processUrl = processUrl;
    exports.validateConfig = validateConfig;

    return exports;

}({}));
